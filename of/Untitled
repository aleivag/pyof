#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2024::*;
#[macro_use]
extern crate std;
use pyo3::prelude::*;
use pyo3::exceptions::PyValueError;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
mod classifier {
    use serde::{Deserialize, Serialize};
    use std::collections::HashMap;
    use regex::Regex;
    use pyo3::prelude::*;
    use pyo3::types::{PyString, PyFloat, PyBool, PyList, PyDict};
    use pyo3::exceptions::PyValueError;
    use crate::attribute::Attribute;
    #[serde(untagged)]
    pub enum Value {
        String(String),
        Number(f64),
        Boolean(bool),
        Classifier(Box<Classifier>),
        Array(Vec<Value>),
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Value {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Value::String(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    Value::Number(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    Value::Boolean(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    Value::Classifier(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    Value::Array(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Value {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                let __content = <_serde::__private::de::Content as _serde::Deserialize>::deserialize(
                    __deserializer,
                )?;
                let __deserializer = _serde::__private::de::ContentRefDeserializer::<
                    __D::Error,
                >::new(&__content);
                if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                    <String as _serde::Deserialize>::deserialize(__deserializer),
                    Value::String,
                ) {
                    return _serde::__private::Ok(__ok);
                }
                if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                    <f64 as _serde::Deserialize>::deserialize(__deserializer),
                    Value::Number,
                ) {
                    return _serde::__private::Ok(__ok);
                }
                if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                    <bool as _serde::Deserialize>::deserialize(__deserializer),
                    Value::Boolean,
                ) {
                    return _serde::__private::Ok(__ok);
                }
                if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                    <Box<
                        Classifier,
                    > as _serde::Deserialize>::deserialize(__deserializer),
                    Value::Classifier,
                ) {
                    return _serde::__private::Ok(__ok);
                }
                if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                    <Vec<Value> as _serde::Deserialize>::deserialize(__deserializer),
                    Value::Array,
                ) {
                    return _serde::__private::Ok(__ok);
                }
                _serde::__private::Err(
                    _serde::de::Error::custom(
                        "data did not match any variant of untagged enum Value",
                    ),
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Value {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Value::String(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "String",
                        &__self_0,
                    )
                }
                Value::Number(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Number",
                        &__self_0,
                    )
                }
                Value::Boolean(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Boolean",
                        &__self_0,
                    )
                }
                Value::Classifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Classifier",
                        &__self_0,
                    )
                }
                Value::Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Array",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Value {
        #[inline]
        fn clone(&self) -> Value {
            match self {
                Value::String(__self_0) => {
                    Value::String(::core::clone::Clone::clone(__self_0))
                }
                Value::Number(__self_0) => {
                    Value::Number(::core::clone::Clone::clone(__self_0))
                }
                Value::Boolean(__self_0) => {
                    Value::Boolean(::core::clone::Clone::clone(__self_0))
                }
                Value::Classifier(__self_0) => {
                    Value::Classifier(::core::clone::Clone::clone(__self_0))
                }
                Value::Array(__self_0) => {
                    Value::Array(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    impl<'source> FromPyObject<'source> for Value {
        fn extract(ob: &PyAny) -> PyResult<Self> {
            if let Ok(s) = ob.extract::<String>() {
                Ok(Value::String(s))
            } else if let Ok(f) = ob.extract::<f64>() {
                Ok(Value::Number(f))
            } else if let Ok(b) = ob.extract::<bool>() {
                Ok(Value::Boolean(b))
            } else if let Ok(c) = ob.extract::<PyRef<Classifier>>() {
                Ok(Value::Classifier(Box::new(c.clone())))
            } else if let Ok(l) = ob.extract::<Py<PyList>>() {
                let mut vec = Vec::new();
                for item in l.as_ref(ob.py()).iter() {
                    vec.push(item.extract()?);
                }
                Ok(Value::Array(vec))
            } else {
                Err(PyValueError::new_err("Could not convert Python object to Value"))
            }
        }
    }
    impl IntoPy<PyObject> for Value {
        fn into_py(self, py: Python) -> PyObject {
            match self {
                Value::String(s) => s.into_py(py),
                Value::Number(f) => f.into_py(py),
                Value::Boolean(b) => b.into_py(py),
                Value::Classifier(c) => c.into_py(py),
                Value::Array(v) => v.into_py(py),
            }
        }
    }
    #[serde(tag = "type")]
    pub enum Classifier {
        #[serde(rename = "re.match")]
        REGEXMATCH { attribute: Attribute, value: Value },
        #[serde(rename = "bool.all")]
        ALL { attribute: Option<Attribute>, value: Vec<Classifier> },
        #[serde(rename = "bool.any")]
        ANY { attribute: Option<Attribute>, value: Vec<Classifier> },
        #[serde(rename = "comparison.lt")]
        LT { attribute: Attribute, value: Value },
        #[serde(rename = "comparison.gt")]
        GT { attribute: Attribute, value: Value },
        #[serde(rename = "comparison.gte")]
        GTE { attribute: Attribute, value: Value },
        #[serde(rename = "comparison.lte")]
        LTE { attribute: Attribute, value: Value },
        #[serde(rename = "comparison.eq")]
        EQ { attribute: Attribute, value: Value },
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Classifier {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Classifier::REGEXMATCH { ref attribute, ref value } => {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Classifier",
                            0 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "re.match",
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "attribute",
                            attribute,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "value",
                            value,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    Classifier::ALL { ref attribute, ref value } => {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Classifier",
                            0 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "bool.all",
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "attribute",
                            attribute,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "value",
                            value,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    Classifier::ANY { ref attribute, ref value } => {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Classifier",
                            0 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "bool.any",
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "attribute",
                            attribute,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "value",
                            value,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    Classifier::LT { ref attribute, ref value } => {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Classifier",
                            0 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "comparison.lt",
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "attribute",
                            attribute,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "value",
                            value,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    Classifier::GT { ref attribute, ref value } => {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Classifier",
                            0 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "comparison.gt",
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "attribute",
                            attribute,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "value",
                            value,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    Classifier::GTE { ref attribute, ref value } => {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Classifier",
                            0 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "comparison.gte",
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "attribute",
                            attribute,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "value",
                            value,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    Classifier::LTE { ref attribute, ref value } => {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Classifier",
                            0 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "comparison.lte",
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "attribute",
                            attribute,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "value",
                            value,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    Classifier::EQ { ref attribute, ref value } => {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Classifier",
                            0 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "comparison.eq",
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "attribute",
                            attribute,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "value",
                            value,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Classifier {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 8",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "re.match" => _serde::__private::Ok(__Field::__field0),
                            "bool.all" => _serde::__private::Ok(__Field::__field1),
                            "bool.any" => _serde::__private::Ok(__Field::__field2),
                            "comparison.lt" => _serde::__private::Ok(__Field::__field3),
                            "comparison.gt" => _serde::__private::Ok(__Field::__field4),
                            "comparison.gte" => _serde::__private::Ok(__Field::__field5),
                            "comparison.lte" => _serde::__private::Ok(__Field::__field6),
                            "comparison.eq" => _serde::__private::Ok(__Field::__field7),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"re.match" => _serde::__private::Ok(__Field::__field0),
                            b"bool.all" => _serde::__private::Ok(__Field::__field1),
                            b"bool.any" => _serde::__private::Ok(__Field::__field2),
                            b"comparison.lt" => _serde::__private::Ok(__Field::__field3),
                            b"comparison.gt" => _serde::__private::Ok(__Field::__field4),
                            b"comparison.gte" => _serde::__private::Ok(__Field::__field5),
                            b"comparison.lte" => _serde::__private::Ok(__Field::__field6),
                            b"comparison.eq" => _serde::__private::Ok(__Field::__field7),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "re.match",
                    "bool.all",
                    "bool.any",
                    "comparison.lt",
                    "comparison.gt",
                    "comparison.gte",
                    "comparison.lte",
                    "comparison.eq",
                ];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new("type", "internally tagged enum Classifier"),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "attribute" => _serde::__private::Ok(__Field::__field0),
                                    "value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"attribute" => _serde::__private::Ok(__Field::__field0),
                                    b"value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Classifier>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Classifier;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct variant Classifier::REGEXMATCH",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Attribute,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct variant Classifier::REGEXMATCH with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Value,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct variant Classifier::REGEXMATCH with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Classifier::REGEXMATCH {
                                    attribute: __field0,
                                    value: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Attribute> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Value> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "attribute",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Attribute>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("value"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Value>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("attribute")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("value")?
                                    }
                                };
                                _serde::__private::Ok(Classifier::REGEXMATCH {
                                    attribute: __field0,
                                    value: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["attribute", "value"];
                        _serde::Deserializer::deserialize_any(
                            __deserializer,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Classifier>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                    __Field::__field1 => {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "attribute" => _serde::__private::Ok(__Field::__field0),
                                    "value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"attribute" => _serde::__private::Ok(__Field::__field0),
                                    b"value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Classifier>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Classifier;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct variant Classifier::ALL",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Option<Attribute>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct variant Classifier::ALL with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Vec<Classifier>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct variant Classifier::ALL with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Classifier::ALL {
                                    attribute: __field0,
                                    value: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    Option<Attribute>,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Vec<Classifier>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "attribute",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<Attribute>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("value"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Vec<Classifier>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("attribute")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("value")?
                                    }
                                };
                                _serde::__private::Ok(Classifier::ALL {
                                    attribute: __field0,
                                    value: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["attribute", "value"];
                        _serde::Deserializer::deserialize_any(
                            __deserializer,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Classifier>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                    __Field::__field2 => {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "attribute" => _serde::__private::Ok(__Field::__field0),
                                    "value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"attribute" => _serde::__private::Ok(__Field::__field0),
                                    b"value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Classifier>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Classifier;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct variant Classifier::ANY",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Option<Attribute>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct variant Classifier::ANY with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Vec<Classifier>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct variant Classifier::ANY with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Classifier::ANY {
                                    attribute: __field0,
                                    value: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    Option<Attribute>,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Vec<Classifier>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "attribute",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<Attribute>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("value"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Vec<Classifier>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("attribute")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("value")?
                                    }
                                };
                                _serde::__private::Ok(Classifier::ANY {
                                    attribute: __field0,
                                    value: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["attribute", "value"];
                        _serde::Deserializer::deserialize_any(
                            __deserializer,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Classifier>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                    __Field::__field3 => {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "attribute" => _serde::__private::Ok(__Field::__field0),
                                    "value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"attribute" => _serde::__private::Ok(__Field::__field0),
                                    b"value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Classifier>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Classifier;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct variant Classifier::LT",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Attribute,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct variant Classifier::LT with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Value,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct variant Classifier::LT with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Classifier::LT {
                                    attribute: __field0,
                                    value: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Attribute> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Value> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "attribute",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Attribute>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("value"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Value>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("attribute")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("value")?
                                    }
                                };
                                _serde::__private::Ok(Classifier::LT {
                                    attribute: __field0,
                                    value: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["attribute", "value"];
                        _serde::Deserializer::deserialize_any(
                            __deserializer,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Classifier>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                    __Field::__field4 => {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "attribute" => _serde::__private::Ok(__Field::__field0),
                                    "value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"attribute" => _serde::__private::Ok(__Field::__field0),
                                    b"value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Classifier>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Classifier;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct variant Classifier::GT",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Attribute,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct variant Classifier::GT with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Value,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct variant Classifier::GT with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Classifier::GT {
                                    attribute: __field0,
                                    value: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Attribute> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Value> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "attribute",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Attribute>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("value"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Value>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("attribute")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("value")?
                                    }
                                };
                                _serde::__private::Ok(Classifier::GT {
                                    attribute: __field0,
                                    value: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["attribute", "value"];
                        _serde::Deserializer::deserialize_any(
                            __deserializer,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Classifier>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                    __Field::__field5 => {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "attribute" => _serde::__private::Ok(__Field::__field0),
                                    "value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"attribute" => _serde::__private::Ok(__Field::__field0),
                                    b"value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Classifier>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Classifier;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct variant Classifier::GTE",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Attribute,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct variant Classifier::GTE with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Value,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct variant Classifier::GTE with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Classifier::GTE {
                                    attribute: __field0,
                                    value: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Attribute> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Value> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "attribute",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Attribute>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("value"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Value>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("attribute")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("value")?
                                    }
                                };
                                _serde::__private::Ok(Classifier::GTE {
                                    attribute: __field0,
                                    value: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["attribute", "value"];
                        _serde::Deserializer::deserialize_any(
                            __deserializer,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Classifier>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                    __Field::__field6 => {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "attribute" => _serde::__private::Ok(__Field::__field0),
                                    "value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"attribute" => _serde::__private::Ok(__Field::__field0),
                                    b"value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Classifier>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Classifier;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct variant Classifier::LTE",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Attribute,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct variant Classifier::LTE with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Value,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct variant Classifier::LTE with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Classifier::LTE {
                                    attribute: __field0,
                                    value: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Attribute> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Value> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "attribute",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Attribute>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("value"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Value>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("attribute")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("value")?
                                    }
                                };
                                _serde::__private::Ok(Classifier::LTE {
                                    attribute: __field0,
                                    value: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["attribute", "value"];
                        _serde::Deserializer::deserialize_any(
                            __deserializer,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Classifier>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                    __Field::__field7 => {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "attribute" => _serde::__private::Ok(__Field::__field0),
                                    "value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"attribute" => _serde::__private::Ok(__Field::__field0),
                                    b"value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Classifier>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Classifier;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct variant Classifier::EQ",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Attribute,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct variant Classifier::EQ with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Value,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct variant Classifier::EQ with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Classifier::EQ {
                                    attribute: __field0,
                                    value: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Attribute> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Value> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "attribute",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Attribute>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("value"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Value>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("attribute")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("value")?
                                    }
                                };
                                _serde::__private::Ok(Classifier::EQ {
                                    attribute: __field0,
                                    value: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["attribute", "value"];
                        _serde::Deserializer::deserialize_any(
                            __deserializer,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Classifier>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Classifier {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Classifier::REGEXMATCH { attribute: __self_0, value: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "REGEXMATCH",
                        "attribute",
                        __self_0,
                        "value",
                        &__self_1,
                    )
                }
                Classifier::ALL { attribute: __self_0, value: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "ALL",
                        "attribute",
                        __self_0,
                        "value",
                        &__self_1,
                    )
                }
                Classifier::ANY { attribute: __self_0, value: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "ANY",
                        "attribute",
                        __self_0,
                        "value",
                        &__self_1,
                    )
                }
                Classifier::LT { attribute: __self_0, value: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "LT",
                        "attribute",
                        __self_0,
                        "value",
                        &__self_1,
                    )
                }
                Classifier::GT { attribute: __self_0, value: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "GT",
                        "attribute",
                        __self_0,
                        "value",
                        &__self_1,
                    )
                }
                Classifier::GTE { attribute: __self_0, value: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "GTE",
                        "attribute",
                        __self_0,
                        "value",
                        &__self_1,
                    )
                }
                Classifier::LTE { attribute: __self_0, value: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "LTE",
                        "attribute",
                        __self_0,
                        "value",
                        &__self_1,
                    )
                }
                Classifier::EQ { attribute: __self_0, value: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "EQ",
                        "attribute",
                        __self_0,
                        "value",
                        &__self_1,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Classifier {
        #[inline]
        fn clone(&self) -> Classifier {
            match self {
                Classifier::REGEXMATCH { attribute: __self_0, value: __self_1 } => {
                    Classifier::REGEXMATCH {
                        attribute: ::core::clone::Clone::clone(__self_0),
                        value: ::core::clone::Clone::clone(__self_1),
                    }
                }
                Classifier::ALL { attribute: __self_0, value: __self_1 } => {
                    Classifier::ALL {
                        attribute: ::core::clone::Clone::clone(__self_0),
                        value: ::core::clone::Clone::clone(__self_1),
                    }
                }
                Classifier::ANY { attribute: __self_0, value: __self_1 } => {
                    Classifier::ANY {
                        attribute: ::core::clone::Clone::clone(__self_0),
                        value: ::core::clone::Clone::clone(__self_1),
                    }
                }
                Classifier::LT { attribute: __self_0, value: __self_1 } => {
                    Classifier::LT {
                        attribute: ::core::clone::Clone::clone(__self_0),
                        value: ::core::clone::Clone::clone(__self_1),
                    }
                }
                Classifier::GT { attribute: __self_0, value: __self_1 } => {
                    Classifier::GT {
                        attribute: ::core::clone::Clone::clone(__self_0),
                        value: ::core::clone::Clone::clone(__self_1),
                    }
                }
                Classifier::GTE { attribute: __self_0, value: __self_1 } => {
                    Classifier::GTE {
                        attribute: ::core::clone::Clone::clone(__self_0),
                        value: ::core::clone::Clone::clone(__self_1),
                    }
                }
                Classifier::LTE { attribute: __self_0, value: __self_1 } => {
                    Classifier::LTE {
                        attribute: ::core::clone::Clone::clone(__self_0),
                        value: ::core::clone::Clone::clone(__self_1),
                    }
                }
                Classifier::EQ { attribute: __self_0, value: __self_1 } => {
                    Classifier::EQ {
                        attribute: ::core::clone::Clone::clone(__self_0),
                        value: ::core::clone::Clone::clone(__self_1),
                    }
                }
            }
        }
    }
    #[allow(deprecated)]
    unsafe impl ::pyo3::type_object::HasPyGilRef for Classifier {
        type AsRefTarget = ::pyo3::PyCell<Self>;
    }
    unsafe impl ::pyo3::type_object::PyTypeInfo for Classifier {
        const NAME: &'static str = "Classifier";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <Classifier as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    impl ::pyo3::PyClass for Classifier {
        type Frozen = ::pyo3::pyclass::boolean_struct::True;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a Classifier {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, Classifier>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl ::pyo3::IntoPy<::pyo3::PyObject> for Classifier {
        fn into_py(self, py: ::pyo3::Python) -> ::pyo3::PyObject {
            match self {
                Classifier::REGEXMATCH { .. } => {
                    let pyclass_init = ::pyo3::PyClassInitializer::from(self)
                        .add_subclass(Classifier_REGEXMATCH);
                    let variant_value = ::pyo3::Py::new(py, pyclass_init).unwrap();
                    ::pyo3::IntoPy::into_py(variant_value, py)
                }
                Classifier::ALL { .. } => {
                    let pyclass_init = ::pyo3::PyClassInitializer::from(self)
                        .add_subclass(Classifier_ALL);
                    let variant_value = ::pyo3::Py::new(py, pyclass_init).unwrap();
                    ::pyo3::IntoPy::into_py(variant_value, py)
                }
                Classifier::ANY { .. } => {
                    let pyclass_init = ::pyo3::PyClassInitializer::from(self)
                        .add_subclass(Classifier_ANY);
                    let variant_value = ::pyo3::Py::new(py, pyclass_init).unwrap();
                    ::pyo3::IntoPy::into_py(variant_value, py)
                }
                Classifier::LT { .. } => {
                    let pyclass_init = ::pyo3::PyClassInitializer::from(self)
                        .add_subclass(Classifier_LT);
                    let variant_value = ::pyo3::Py::new(py, pyclass_init).unwrap();
                    ::pyo3::IntoPy::into_py(variant_value, py)
                }
                Classifier::GT { .. } => {
                    let pyclass_init = ::pyo3::PyClassInitializer::from(self)
                        .add_subclass(Classifier_GT);
                    let variant_value = ::pyo3::Py::new(py, pyclass_init).unwrap();
                    ::pyo3::IntoPy::into_py(variant_value, py)
                }
                Classifier::GTE { .. } => {
                    let pyclass_init = ::pyo3::PyClassInitializer::from(self)
                        .add_subclass(Classifier_GTE);
                    let variant_value = ::pyo3::Py::new(py, pyclass_init).unwrap();
                    ::pyo3::IntoPy::into_py(variant_value, py)
                }
                Classifier::LTE { .. } => {
                    let pyclass_init = ::pyo3::PyClassInitializer::from(self)
                        .add_subclass(Classifier_LTE);
                    let variant_value = ::pyo3::Py::new(py, pyclass_init).unwrap();
                    ::pyo3::IntoPy::into_py(variant_value, py)
                }
                Classifier::EQ { .. } => {
                    let pyclass_init = ::pyo3::PyClassInitializer::from(self)
                        .add_subclass(Classifier_EQ);
                    let variant_value = ::pyo3::Py::new(py, pyclass_init).unwrap();
                    ::pyo3::IntoPy::into_py(variant_value, py)
                }
            }
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for Classifier {
        const IS_BASETYPE: bool = true;
        const IS_SUBCLASS: bool = false;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = ::pyo3::PyAny;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<Classifier>;
        type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::ImmutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = ::pyo3::PyAny;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    ::pyo3::class::PyMethodDefType::ClassAttribute({
                        ::pyo3::class::PyClassAttributeDef::new(
                            { "REGEXMATCH\0" },
                            ::pyo3::impl_::pymethods::PyClassAttributeFactory(
                                Classifier::__pymethod_variant_cls_REGEXMATCH__,
                            ),
                        )
                    }),
                    ::pyo3::class::PyMethodDefType::ClassAttribute({
                        ::pyo3::class::PyClassAttributeDef::new(
                            { "ALL\0" },
                            ::pyo3::impl_::pymethods::PyClassAttributeFactory(
                                Classifier::__pymethod_variant_cls_ALL__,
                            ),
                        )
                    }),
                    ::pyo3::class::PyMethodDefType::ClassAttribute({
                        ::pyo3::class::PyClassAttributeDef::new(
                            { "ANY\0" },
                            ::pyo3::impl_::pymethods::PyClassAttributeFactory(
                                Classifier::__pymethod_variant_cls_ANY__,
                            ),
                        )
                    }),
                    ::pyo3::class::PyMethodDefType::ClassAttribute({
                        ::pyo3::class::PyClassAttributeDef::new(
                            { "LT\0" },
                            ::pyo3::impl_::pymethods::PyClassAttributeFactory(
                                Classifier::__pymethod_variant_cls_LT__,
                            ),
                        )
                    }),
                    ::pyo3::class::PyMethodDefType::ClassAttribute({
                        ::pyo3::class::PyClassAttributeDef::new(
                            { "GT\0" },
                            ::pyo3::impl_::pymethods::PyClassAttributeFactory(
                                Classifier::__pymethod_variant_cls_GT__,
                            ),
                        )
                    }),
                    ::pyo3::class::PyMethodDefType::ClassAttribute({
                        ::pyo3::class::PyClassAttributeDef::new(
                            { "GTE\0" },
                            ::pyo3::impl_::pymethods::PyClassAttributeFactory(
                                Classifier::__pymethod_variant_cls_GTE__,
                            ),
                        )
                    }),
                    ::pyo3::class::PyMethodDefType::ClassAttribute({
                        ::pyo3::class::PyClassAttributeDef::new(
                            { "LTE\0" },
                            ::pyo3::impl_::pymethods::PyClassAttributeFactory(
                                Classifier::__pymethod_variant_cls_LTE__,
                            ),
                        )
                    }),
                    ::pyo3::class::PyMethodDefType::ClassAttribute({
                        ::pyo3::class::PyClassAttributeDef::new(
                            { "EQ\0" },
                            ::pyo3::impl_::pymethods::PyClassAttributeFactory(
                                Classifier::__pymethod_variant_cls_EQ__,
                            ),
                        )
                    }),
                ],
                slots: &[],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <Classifier as ::pyo3::PyTypeInfo>::NAME,
                            "\0",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<Classifier> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier {
        fn __pymethod_variant_cls_REGEXMATCH__(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                py.get_type_bound::<Classifier_REGEXMATCH>().into_any().unbind(),
            )
        }
        fn __pymethod_variant_cls_ALL__(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                py.get_type_bound::<Classifier_ALL>().into_any().unbind(),
            )
        }
        fn __pymethod_variant_cls_ANY__(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                py.get_type_bound::<Classifier_ANY>().into_any().unbind(),
            )
        }
        fn __pymethod_variant_cls_LT__(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                py.get_type_bound::<Classifier_LT>().into_any().unbind(),
            )
        }
        fn __pymethod_variant_cls_GT__(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                py.get_type_bound::<Classifier_GT>().into_any().unbind(),
            )
        }
        fn __pymethod_variant_cls_GTE__(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                py.get_type_bound::<Classifier_GTE>().into_any().unbind(),
            )
        }
        fn __pymethod_variant_cls_LTE__(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                py.get_type_bound::<Classifier_LTE>().into_any().unbind(),
            )
        }
        fn __pymethod_variant_cls_EQ__(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                py.get_type_bound::<Classifier_EQ>().into_any().unbind(),
            )
        }
    }
    impl Classifier {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier {}
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    struct Classifier_REGEXMATCH;
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    struct Classifier_ALL;
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    struct Classifier_ANY;
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    struct Classifier_LT;
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    struct Classifier_GT;
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    struct Classifier_GTE;
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    struct Classifier_LTE;
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    struct Classifier_EQ;
    #[allow(deprecated)]
    unsafe impl ::pyo3::type_object::HasPyGilRef for Classifier_REGEXMATCH {
        type AsRefTarget = ::pyo3::PyCell<Self>;
    }
    unsafe impl ::pyo3::type_object::PyTypeInfo for Classifier_REGEXMATCH {
        const NAME: &'static str = "Classifier_REGEXMATCH";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <Classifier_REGEXMATCH as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    #[allow(deprecated)]
    unsafe impl ::pyo3::type_object::HasPyGilRef for Classifier_ALL {
        type AsRefTarget = ::pyo3::PyCell<Self>;
    }
    unsafe impl ::pyo3::type_object::PyTypeInfo for Classifier_ALL {
        const NAME: &'static str = "Classifier_ALL";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <Classifier_ALL as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    #[allow(deprecated)]
    unsafe impl ::pyo3::type_object::HasPyGilRef for Classifier_ANY {
        type AsRefTarget = ::pyo3::PyCell<Self>;
    }
    unsafe impl ::pyo3::type_object::PyTypeInfo for Classifier_ANY {
        const NAME: &'static str = "Classifier_ANY";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <Classifier_ANY as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    #[allow(deprecated)]
    unsafe impl ::pyo3::type_object::HasPyGilRef for Classifier_LT {
        type AsRefTarget = ::pyo3::PyCell<Self>;
    }
    unsafe impl ::pyo3::type_object::PyTypeInfo for Classifier_LT {
        const NAME: &'static str = "Classifier_LT";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <Classifier_LT as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    #[allow(deprecated)]
    unsafe impl ::pyo3::type_object::HasPyGilRef for Classifier_GT {
        type AsRefTarget = ::pyo3::PyCell<Self>;
    }
    unsafe impl ::pyo3::type_object::PyTypeInfo for Classifier_GT {
        const NAME: &'static str = "Classifier_GT";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <Classifier_GT as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    #[allow(deprecated)]
    unsafe impl ::pyo3::type_object::HasPyGilRef for Classifier_GTE {
        type AsRefTarget = ::pyo3::PyCell<Self>;
    }
    unsafe impl ::pyo3::type_object::PyTypeInfo for Classifier_GTE {
        const NAME: &'static str = "Classifier_GTE";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <Classifier_GTE as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    #[allow(deprecated)]
    unsafe impl ::pyo3::type_object::HasPyGilRef for Classifier_LTE {
        type AsRefTarget = ::pyo3::PyCell<Self>;
    }
    unsafe impl ::pyo3::type_object::PyTypeInfo for Classifier_LTE {
        const NAME: &'static str = "Classifier_LTE";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <Classifier_LTE as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    #[allow(deprecated)]
    unsafe impl ::pyo3::type_object::HasPyGilRef for Classifier_EQ {
        type AsRefTarget = ::pyo3::PyCell<Self>;
    }
    unsafe impl ::pyo3::type_object::PyTypeInfo for Classifier_EQ {
        const NAME: &'static str = "Classifier_EQ";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <Classifier_EQ as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    impl ::pyo3::PyClass for Classifier_REGEXMATCH {
        type Frozen = ::pyo3::pyclass::boolean_struct::True;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a Classifier_REGEXMATCH {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, Classifier_REGEXMATCH>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for Classifier_REGEXMATCH {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = true;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = Classifier;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<
            Classifier_REGEXMATCH,
        >;
        type PyClassMutability = <<Classifier as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::ImmutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = <Self::BaseType as ::pyo3::impl_::pyclass::PyClassBaseType>::BaseNativeType;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    ::pyo3::class::PyMethodDefType::Getter(
                        ::pyo3::class::PyGetterDef::new(
                            "attribute\0",
                            ::pyo3::impl_::pymethods::PyGetter(
                                Classifier_REGEXMATCH::__pymethod_get_attribute__,
                            ),
                            "\0",
                        ),
                    ),
                    ::pyo3::class::PyMethodDefType::Getter(
                        ::pyo3::class::PyGetterDef::new(
                            "value\0",
                            ::pyo3::impl_::pymethods::PyGetter(
                                Classifier_REGEXMATCH::__pymethod_get_value__,
                            ),
                            "\0",
                        ),
                    ),
                ],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<Classifier_REGEXMATCH>
                                for PyClassImplCollector<Classifier_REGEXMATCH> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("(attribute, value)")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    Classifier_REGEXMATCH::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <Classifier_REGEXMATCH as ::pyo3::PyTypeInfo>::NAME,
                            "\0",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<Classifier_REGEXMATCH> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier_REGEXMATCH {
        unsafe fn __pymethod_get_attribute__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                Classifier_REGEXMATCH::attribute(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<Classifier_REGEXMATCH>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        unsafe fn __pymethod_get_value__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                Classifier_REGEXMATCH::value(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<Classifier_REGEXMATCH>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = Classifier_REGEXMATCH::__pymethod_constructor__;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <Classifier_REGEXMATCH as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &["attribute", "value"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 2usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 2usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_1 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_2 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = Classifier_REGEXMATCH::__pymethod_constructor__(
                ::pyo3::impl_::deprecations::inspect_type(py, &gil_refs_checker_0),
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[0usize].as_deref(),
                        ),
                        &mut holder_0,
                        "attribute",
                    )?,
                    &gil_refs_checker_1,
                ),
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[1usize].as_deref(),
                        ),
                        &mut holder_1,
                        "value",
                    )?,
                    &gil_refs_checker_2,
                ),
            );
            let initializer: ::pyo3::PyClassInitializer<Classifier_REGEXMATCH> = result
                .convert(py)?;
            gil_refs_checker_0.function_arg();
            gil_refs_checker_1.function_arg();
            gil_refs_checker_2.function_arg();
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl Classifier_REGEXMATCH {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    impl ::pyo3::PyClass for Classifier_ALL {
        type Frozen = ::pyo3::pyclass::boolean_struct::True;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a Classifier_ALL {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, Classifier_ALL>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for Classifier_ALL {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = true;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = Classifier;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<Classifier_ALL>;
        type PyClassMutability = <<Classifier as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::ImmutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = <Self::BaseType as ::pyo3::impl_::pyclass::PyClassBaseType>::BaseNativeType;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    ::pyo3::class::PyMethodDefType::Getter(
                        ::pyo3::class::PyGetterDef::new(
                            "attribute\0",
                            ::pyo3::impl_::pymethods::PyGetter(
                                Classifier_ALL::__pymethod_get_attribute__,
                            ),
                            "\0",
                        ),
                    ),
                    ::pyo3::class::PyMethodDefType::Getter(
                        ::pyo3::class::PyGetterDef::new(
                            "value\0",
                            ::pyo3::impl_::pymethods::PyGetter(
                                Classifier_ALL::__pymethod_get_value__,
                            ),
                            "\0",
                        ),
                    ),
                ],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<Classifier_ALL>
                                for PyClassImplCollector<Classifier_ALL> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("(attribute, value)")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    Classifier_ALL::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <Classifier_ALL as ::pyo3::PyTypeInfo>::NAME,
                            "\0",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<Classifier_ALL> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier_ALL {
        unsafe fn __pymethod_get_attribute__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                Classifier_ALL::attribute(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<Classifier_ALL>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        unsafe fn __pymethod_get_value__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                Classifier_ALL::value(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<Classifier_ALL>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = Classifier_ALL::__pymethod_constructor__;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <Classifier_ALL as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &["attribute", "value"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 2usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 2usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_1 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_2 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = Classifier_ALL::__pymethod_constructor__(
                ::pyo3::impl_::deprecations::inspect_type(py, &gil_refs_checker_0),
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[0usize].as_deref(),
                        ),
                        &mut holder_0,
                        "attribute",
                    )?,
                    &gil_refs_checker_1,
                ),
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[1usize].as_deref(),
                        ),
                        &mut holder_1,
                        "value",
                    )?,
                    &gil_refs_checker_2,
                ),
            );
            let initializer: ::pyo3::PyClassInitializer<Classifier_ALL> = result
                .convert(py)?;
            gil_refs_checker_0.function_arg();
            gil_refs_checker_1.function_arg();
            gil_refs_checker_2.function_arg();
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl Classifier_ALL {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    impl ::pyo3::PyClass for Classifier_ANY {
        type Frozen = ::pyo3::pyclass::boolean_struct::True;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a Classifier_ANY {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, Classifier_ANY>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for Classifier_ANY {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = true;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = Classifier;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<Classifier_ANY>;
        type PyClassMutability = <<Classifier as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::ImmutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = <Self::BaseType as ::pyo3::impl_::pyclass::PyClassBaseType>::BaseNativeType;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    ::pyo3::class::PyMethodDefType::Getter(
                        ::pyo3::class::PyGetterDef::new(
                            "attribute\0",
                            ::pyo3::impl_::pymethods::PyGetter(
                                Classifier_ANY::__pymethod_get_attribute__,
                            ),
                            "\0",
                        ),
                    ),
                    ::pyo3::class::PyMethodDefType::Getter(
                        ::pyo3::class::PyGetterDef::new(
                            "value\0",
                            ::pyo3::impl_::pymethods::PyGetter(
                                Classifier_ANY::__pymethod_get_value__,
                            ),
                            "\0",
                        ),
                    ),
                ],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<Classifier_ANY>
                                for PyClassImplCollector<Classifier_ANY> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("(attribute, value)")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    Classifier_ANY::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <Classifier_ANY as ::pyo3::PyTypeInfo>::NAME,
                            "\0",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<Classifier_ANY> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier_ANY {
        unsafe fn __pymethod_get_attribute__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                Classifier_ANY::attribute(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<Classifier_ANY>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        unsafe fn __pymethod_get_value__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                Classifier_ANY::value(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<Classifier_ANY>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = Classifier_ANY::__pymethod_constructor__;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <Classifier_ANY as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &["attribute", "value"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 2usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 2usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_1 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_2 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = Classifier_ANY::__pymethod_constructor__(
                ::pyo3::impl_::deprecations::inspect_type(py, &gil_refs_checker_0),
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[0usize].as_deref(),
                        ),
                        &mut holder_0,
                        "attribute",
                    )?,
                    &gil_refs_checker_1,
                ),
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[1usize].as_deref(),
                        ),
                        &mut holder_1,
                        "value",
                    )?,
                    &gil_refs_checker_2,
                ),
            );
            let initializer: ::pyo3::PyClassInitializer<Classifier_ANY> = result
                .convert(py)?;
            gil_refs_checker_0.function_arg();
            gil_refs_checker_1.function_arg();
            gil_refs_checker_2.function_arg();
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl Classifier_ANY {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    impl ::pyo3::PyClass for Classifier_LT {
        type Frozen = ::pyo3::pyclass::boolean_struct::True;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a Classifier_LT {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, Classifier_LT>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for Classifier_LT {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = true;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = Classifier;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<Classifier_LT>;
        type PyClassMutability = <<Classifier as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::ImmutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = <Self::BaseType as ::pyo3::impl_::pyclass::PyClassBaseType>::BaseNativeType;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    ::pyo3::class::PyMethodDefType::Getter(
                        ::pyo3::class::PyGetterDef::new(
                            "attribute\0",
                            ::pyo3::impl_::pymethods::PyGetter(
                                Classifier_LT::__pymethod_get_attribute__,
                            ),
                            "\0",
                        ),
                    ),
                    ::pyo3::class::PyMethodDefType::Getter(
                        ::pyo3::class::PyGetterDef::new(
                            "value\0",
                            ::pyo3::impl_::pymethods::PyGetter(
                                Classifier_LT::__pymethod_get_value__,
                            ),
                            "\0",
                        ),
                    ),
                ],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<Classifier_LT>
                                for PyClassImplCollector<Classifier_LT> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("(attribute, value)")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    Classifier_LT::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <Classifier_LT as ::pyo3::PyTypeInfo>::NAME,
                            "\0",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<Classifier_LT> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier_LT {
        unsafe fn __pymethod_get_attribute__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                Classifier_LT::attribute(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<Classifier_LT>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        unsafe fn __pymethod_get_value__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                Classifier_LT::value(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<Classifier_LT>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = Classifier_LT::__pymethod_constructor__;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <Classifier_LT as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &["attribute", "value"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 2usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 2usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_1 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_2 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = Classifier_LT::__pymethod_constructor__(
                ::pyo3::impl_::deprecations::inspect_type(py, &gil_refs_checker_0),
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[0usize].as_deref(),
                        ),
                        &mut holder_0,
                        "attribute",
                    )?,
                    &gil_refs_checker_1,
                ),
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[1usize].as_deref(),
                        ),
                        &mut holder_1,
                        "value",
                    )?,
                    &gil_refs_checker_2,
                ),
            );
            let initializer: ::pyo3::PyClassInitializer<Classifier_LT> = result
                .convert(py)?;
            gil_refs_checker_0.function_arg();
            gil_refs_checker_1.function_arg();
            gil_refs_checker_2.function_arg();
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl Classifier_LT {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    impl ::pyo3::PyClass for Classifier_GT {
        type Frozen = ::pyo3::pyclass::boolean_struct::True;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a Classifier_GT {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, Classifier_GT>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for Classifier_GT {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = true;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = Classifier;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<Classifier_GT>;
        type PyClassMutability = <<Classifier as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::ImmutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = <Self::BaseType as ::pyo3::impl_::pyclass::PyClassBaseType>::BaseNativeType;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    ::pyo3::class::PyMethodDefType::Getter(
                        ::pyo3::class::PyGetterDef::new(
                            "attribute\0",
                            ::pyo3::impl_::pymethods::PyGetter(
                                Classifier_GT::__pymethod_get_attribute__,
                            ),
                            "\0",
                        ),
                    ),
                    ::pyo3::class::PyMethodDefType::Getter(
                        ::pyo3::class::PyGetterDef::new(
                            "value\0",
                            ::pyo3::impl_::pymethods::PyGetter(
                                Classifier_GT::__pymethod_get_value__,
                            ),
                            "\0",
                        ),
                    ),
                ],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<Classifier_GT>
                                for PyClassImplCollector<Classifier_GT> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("(attribute, value)")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    Classifier_GT::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <Classifier_GT as ::pyo3::PyTypeInfo>::NAME,
                            "\0",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<Classifier_GT> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier_GT {
        unsafe fn __pymethod_get_attribute__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                Classifier_GT::attribute(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<Classifier_GT>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        unsafe fn __pymethod_get_value__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                Classifier_GT::value(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<Classifier_GT>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = Classifier_GT::__pymethod_constructor__;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <Classifier_GT as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &["attribute", "value"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 2usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 2usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_1 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_2 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = Classifier_GT::__pymethod_constructor__(
                ::pyo3::impl_::deprecations::inspect_type(py, &gil_refs_checker_0),
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[0usize].as_deref(),
                        ),
                        &mut holder_0,
                        "attribute",
                    )?,
                    &gil_refs_checker_1,
                ),
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[1usize].as_deref(),
                        ),
                        &mut holder_1,
                        "value",
                    )?,
                    &gil_refs_checker_2,
                ),
            );
            let initializer: ::pyo3::PyClassInitializer<Classifier_GT> = result
                .convert(py)?;
            gil_refs_checker_0.function_arg();
            gil_refs_checker_1.function_arg();
            gil_refs_checker_2.function_arg();
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl Classifier_GT {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    impl ::pyo3::PyClass for Classifier_GTE {
        type Frozen = ::pyo3::pyclass::boolean_struct::True;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a Classifier_GTE {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, Classifier_GTE>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for Classifier_GTE {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = true;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = Classifier;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<Classifier_GTE>;
        type PyClassMutability = <<Classifier as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::ImmutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = <Self::BaseType as ::pyo3::impl_::pyclass::PyClassBaseType>::BaseNativeType;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    ::pyo3::class::PyMethodDefType::Getter(
                        ::pyo3::class::PyGetterDef::new(
                            "attribute\0",
                            ::pyo3::impl_::pymethods::PyGetter(
                                Classifier_GTE::__pymethod_get_attribute__,
                            ),
                            "\0",
                        ),
                    ),
                    ::pyo3::class::PyMethodDefType::Getter(
                        ::pyo3::class::PyGetterDef::new(
                            "value\0",
                            ::pyo3::impl_::pymethods::PyGetter(
                                Classifier_GTE::__pymethod_get_value__,
                            ),
                            "\0",
                        ),
                    ),
                ],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<Classifier_GTE>
                                for PyClassImplCollector<Classifier_GTE> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("(attribute, value)")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    Classifier_GTE::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <Classifier_GTE as ::pyo3::PyTypeInfo>::NAME,
                            "\0",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<Classifier_GTE> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier_GTE {
        unsafe fn __pymethod_get_attribute__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                Classifier_GTE::attribute(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<Classifier_GTE>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        unsafe fn __pymethod_get_value__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                Classifier_GTE::value(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<Classifier_GTE>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = Classifier_GTE::__pymethod_constructor__;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <Classifier_GTE as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &["attribute", "value"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 2usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 2usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_1 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_2 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = Classifier_GTE::__pymethod_constructor__(
                ::pyo3::impl_::deprecations::inspect_type(py, &gil_refs_checker_0),
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[0usize].as_deref(),
                        ),
                        &mut holder_0,
                        "attribute",
                    )?,
                    &gil_refs_checker_1,
                ),
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[1usize].as_deref(),
                        ),
                        &mut holder_1,
                        "value",
                    )?,
                    &gil_refs_checker_2,
                ),
            );
            let initializer: ::pyo3::PyClassInitializer<Classifier_GTE> = result
                .convert(py)?;
            gil_refs_checker_0.function_arg();
            gil_refs_checker_1.function_arg();
            gil_refs_checker_2.function_arg();
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl Classifier_GTE {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    impl ::pyo3::PyClass for Classifier_LTE {
        type Frozen = ::pyo3::pyclass::boolean_struct::True;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a Classifier_LTE {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, Classifier_LTE>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for Classifier_LTE {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = true;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = Classifier;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<Classifier_LTE>;
        type PyClassMutability = <<Classifier as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::ImmutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = <Self::BaseType as ::pyo3::impl_::pyclass::PyClassBaseType>::BaseNativeType;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    ::pyo3::class::PyMethodDefType::Getter(
                        ::pyo3::class::PyGetterDef::new(
                            "attribute\0",
                            ::pyo3::impl_::pymethods::PyGetter(
                                Classifier_LTE::__pymethod_get_attribute__,
                            ),
                            "\0",
                        ),
                    ),
                    ::pyo3::class::PyMethodDefType::Getter(
                        ::pyo3::class::PyGetterDef::new(
                            "value\0",
                            ::pyo3::impl_::pymethods::PyGetter(
                                Classifier_LTE::__pymethod_get_value__,
                            ),
                            "\0",
                        ),
                    ),
                ],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<Classifier_LTE>
                                for PyClassImplCollector<Classifier_LTE> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("(attribute, value)")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    Classifier_LTE::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <Classifier_LTE as ::pyo3::PyTypeInfo>::NAME,
                            "\0",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<Classifier_LTE> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier_LTE {
        unsafe fn __pymethod_get_attribute__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                Classifier_LTE::attribute(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<Classifier_LTE>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        unsafe fn __pymethod_get_value__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                Classifier_LTE::value(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<Classifier_LTE>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = Classifier_LTE::__pymethod_constructor__;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <Classifier_LTE as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &["attribute", "value"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 2usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 2usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_1 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_2 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = Classifier_LTE::__pymethod_constructor__(
                ::pyo3::impl_::deprecations::inspect_type(py, &gil_refs_checker_0),
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[0usize].as_deref(),
                        ),
                        &mut holder_0,
                        "attribute",
                    )?,
                    &gil_refs_checker_1,
                ),
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[1usize].as_deref(),
                        ),
                        &mut holder_1,
                        "value",
                    )?,
                    &gil_refs_checker_2,
                ),
            );
            let initializer: ::pyo3::PyClassInitializer<Classifier_LTE> = result
                .convert(py)?;
            gil_refs_checker_0.function_arg();
            gil_refs_checker_1.function_arg();
            gil_refs_checker_2.function_arg();
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl Classifier_LTE {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    impl ::pyo3::PyClass for Classifier_EQ {
        type Frozen = ::pyo3::pyclass::boolean_struct::True;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a Classifier_EQ {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, Classifier_EQ>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for Classifier_EQ {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = true;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = Classifier;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<Classifier_EQ>;
        type PyClassMutability = <<Classifier as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::ImmutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = <Self::BaseType as ::pyo3::impl_::pyclass::PyClassBaseType>::BaseNativeType;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    ::pyo3::class::PyMethodDefType::Getter(
                        ::pyo3::class::PyGetterDef::new(
                            "attribute\0",
                            ::pyo3::impl_::pymethods::PyGetter(
                                Classifier_EQ::__pymethod_get_attribute__,
                            ),
                            "\0",
                        ),
                    ),
                    ::pyo3::class::PyMethodDefType::Getter(
                        ::pyo3::class::PyGetterDef::new(
                            "value\0",
                            ::pyo3::impl_::pymethods::PyGetter(
                                Classifier_EQ::__pymethod_get_value__,
                            ),
                            "\0",
                        ),
                    ),
                ],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<Classifier_EQ>
                                for PyClassImplCollector<Classifier_EQ> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("(attribute, value)")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    Classifier_EQ::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <Classifier_EQ as ::pyo3::PyTypeInfo>::NAME,
                            "\0",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<Classifier_EQ> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier_EQ {
        unsafe fn __pymethod_get_attribute__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                Classifier_EQ::attribute(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<Classifier_EQ>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        unsafe fn __pymethod_get_value__(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::callback::convert(
                py,
                Classifier_EQ::value(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                        .downcast::<Classifier_EQ>()
                        .map_err(::std::convert::Into::<::pyo3::PyErr>::into)
                        .and_then(
                            #[allow(
                                unknown_lints,
                                clippy::unnecessary_fallible_conversions
                            )]
                            |bound| {
                                ::std::convert::TryFrom::try_from(bound)
                                    .map_err(::std::convert::Into::into)
                            },
                        )?,
                ),
            );
            result
        }
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = Classifier_EQ::__pymethod_constructor__;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <Classifier_EQ as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &["attribute", "value"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 2usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 2usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_1 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_2 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = Classifier_EQ::__pymethod_constructor__(
                ::pyo3::impl_::deprecations::inspect_type(py, &gil_refs_checker_0),
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[0usize].as_deref(),
                        ),
                        &mut holder_0,
                        "attribute",
                    )?,
                    &gil_refs_checker_1,
                ),
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[1usize].as_deref(),
                        ),
                        &mut holder_1,
                        "value",
                    )?,
                    &gil_refs_checker_2,
                ),
            );
            let initializer: ::pyo3::PyClassInitializer<Classifier_EQ> = result
                .convert(py)?;
            gil_refs_checker_0.function_arg();
            gil_refs_checker_1.function_arg();
            gil_refs_checker_2.function_arg();
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
    }
    impl Classifier_EQ {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier_REGEXMATCH {
        fn __pymethod_constructor__(
            py: ::pyo3::Python<'_>,
            attribute: Attribute,
            value: Value,
        ) -> ::pyo3::PyClassInitializer<Classifier_REGEXMATCH> {
            let base_value = Classifier::REGEXMATCH {
                attribute,
                value,
            };
            ::pyo3::PyClassInitializer::from(base_value)
                .add_subclass(Classifier_REGEXMATCH)
        }
        fn attribute(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<Attribute> {
            match &*slf.into_super() {
                Classifier::REGEXMATCH { attribute, .. } => Ok(attribute.clone()),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
        fn value(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<Value> {
            match &*slf.into_super() {
                Classifier::REGEXMATCH { value, .. } => Ok(value.clone()),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier_ALL {
        fn __pymethod_constructor__(
            py: ::pyo3::Python<'_>,
            attribute: Option<Attribute>,
            value: Vec<Classifier>,
        ) -> ::pyo3::PyClassInitializer<Classifier_ALL> {
            let base_value = Classifier::ALL {
                attribute,
                value,
            };
            ::pyo3::PyClassInitializer::from(base_value).add_subclass(Classifier_ALL)
        }
        fn attribute(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<Option<Attribute>> {
            match &*slf.into_super() {
                Classifier::ALL { attribute, .. } => Ok(attribute.clone()),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
        fn value(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<Vec<Classifier>> {
            match &*slf.into_super() {
                Classifier::ALL { value, .. } => Ok(value.clone()),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier_ANY {
        fn __pymethod_constructor__(
            py: ::pyo3::Python<'_>,
            attribute: Option<Attribute>,
            value: Vec<Classifier>,
        ) -> ::pyo3::PyClassInitializer<Classifier_ANY> {
            let base_value = Classifier::ANY {
                attribute,
                value,
            };
            ::pyo3::PyClassInitializer::from(base_value).add_subclass(Classifier_ANY)
        }
        fn attribute(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<Option<Attribute>> {
            match &*slf.into_super() {
                Classifier::ANY { attribute, .. } => Ok(attribute.clone()),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
        fn value(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<Vec<Classifier>> {
            match &*slf.into_super() {
                Classifier::ANY { value, .. } => Ok(value.clone()),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier_LT {
        fn __pymethod_constructor__(
            py: ::pyo3::Python<'_>,
            attribute: Attribute,
            value: Value,
        ) -> ::pyo3::PyClassInitializer<Classifier_LT> {
            let base_value = Classifier::LT { attribute, value };
            ::pyo3::PyClassInitializer::from(base_value).add_subclass(Classifier_LT)
        }
        fn attribute(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<Attribute> {
            match &*slf.into_super() {
                Classifier::LT { attribute, .. } => Ok(attribute.clone()),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
        fn value(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<Value> {
            match &*slf.into_super() {
                Classifier::LT { value, .. } => Ok(value.clone()),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier_GT {
        fn __pymethod_constructor__(
            py: ::pyo3::Python<'_>,
            attribute: Attribute,
            value: Value,
        ) -> ::pyo3::PyClassInitializer<Classifier_GT> {
            let base_value = Classifier::GT { attribute, value };
            ::pyo3::PyClassInitializer::from(base_value).add_subclass(Classifier_GT)
        }
        fn attribute(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<Attribute> {
            match &*slf.into_super() {
                Classifier::GT { attribute, .. } => Ok(attribute.clone()),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
        fn value(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<Value> {
            match &*slf.into_super() {
                Classifier::GT { value, .. } => Ok(value.clone()),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier_GTE {
        fn __pymethod_constructor__(
            py: ::pyo3::Python<'_>,
            attribute: Attribute,
            value: Value,
        ) -> ::pyo3::PyClassInitializer<Classifier_GTE> {
            let base_value = Classifier::GTE {
                attribute,
                value,
            };
            ::pyo3::PyClassInitializer::from(base_value).add_subclass(Classifier_GTE)
        }
        fn attribute(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<Attribute> {
            match &*slf.into_super() {
                Classifier::GTE { attribute, .. } => Ok(attribute.clone()),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
        fn value(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<Value> {
            match &*slf.into_super() {
                Classifier::GTE { value, .. } => Ok(value.clone()),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier_LTE {
        fn __pymethod_constructor__(
            py: ::pyo3::Python<'_>,
            attribute: Attribute,
            value: Value,
        ) -> ::pyo3::PyClassInitializer<Classifier_LTE> {
            let base_value = Classifier::LTE {
                attribute,
                value,
            };
            ::pyo3::PyClassInitializer::from(base_value).add_subclass(Classifier_LTE)
        }
        fn attribute(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<Attribute> {
            match &*slf.into_super() {
                Classifier::LTE { attribute, .. } => Ok(attribute.clone()),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
        fn value(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<Value> {
            match &*slf.into_super() {
                Classifier::LTE { value, .. } => Ok(value.clone()),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier_EQ {
        fn __pymethod_constructor__(
            py: ::pyo3::Python<'_>,
            attribute: Attribute,
            value: Value,
        ) -> ::pyo3::PyClassInitializer<Classifier_EQ> {
            let base_value = Classifier::EQ { attribute, value };
            ::pyo3::PyClassInitializer::from(base_value).add_subclass(Classifier_EQ)
        }
        fn attribute(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<Attribute> {
            match &*slf.into_super() {
                Classifier::EQ { attribute, .. } => Ok(attribute.clone()),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
        fn value(slf: ::pyo3::PyRef<Self>) -> ::pyo3::PyResult<Value> {
            match &*slf.into_super() {
                Classifier::EQ { value, .. } => Ok(value.clone()),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Wrong complex enum variant found in variant wrapper PyClass",
                            ),
                        ),
                    );
                }
            }
        }
    }
    impl Classifier {
        pub fn eval(&self, py: Python) -> bool {
            match self {
                Classifier::REGEXMATCH { attribute, value } => {
                    if let (Value::String(pattern), Ok(attr_py_obj)) = (
                        value,
                        attribute.eval(py),
                    ) {
                        if let Ok(hostname) = attr_py_obj.extract::<String>(py) {
                            let re = Regex::new(pattern).unwrap();
                            re.is_match(&hostname)
                        } else {
                            false
                        }
                    } else {
                        false
                    }
                }
                Classifier::ALL { attribute, value } => value.iter().all(|c| c.eval(py)),
                Classifier::ANY { attribute, value } => false,
                Classifier::LT { attribute, value } => false,
                Classifier::GT { attribute, value } => false,
                Classifier::GTE { attribute, value } => false,
                Classifier::LTE { attribute, value } => false,
                Classifier::EQ { attribute, value } => false,
            }
        }
    }
    impl ::pyo3::impl_::pyclass::PyMethods<Classifier>
    for ::pyo3::impl_::pyclass::PyClassImplCollector<Classifier> {
        fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
            static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                methods: &[
                    ::pyo3::class::PyMethodDefType::Method(
                        ::pyo3::impl_::pymethods::PyMethodDef::noargs(
                            "eval\0",
                            ::pyo3::impl_::pymethods::PyCFunction({
                                unsafe extern "C" fn trampoline(
                                    _slf: *mut ::pyo3::ffi::PyObject,
                                    _args: *mut ::pyo3::ffi::PyObject,
                                ) -> *mut ::pyo3::ffi::PyObject {
                                    ::pyo3::impl_::trampoline::noargs(
                                        _slf,
                                        _args,
                                        Classifier::__pymethod_eval__,
                                    )
                                }
                                trampoline
                            }),
                            "eval($self)\n--\n\n\0",
                        ),
                    ),
                ],
                slots: &[],
            };
            &ITEMS
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Classifier {
        unsafe fn __pymethod_eval__<'py>(
            py: ::pyo3::Python<'py>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            let _slf_ref = &_slf;
            let function = Classifier::eval;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = ::pyo3::impl_::wrap::map_result_into_ptr(
                py,
                ::pyo3::impl_::wrap::OkWrap::wrap(
                        function(
                            ::pyo3::impl_::deprecations::inspect_type(
                                ::pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                    Classifier,
                                >(
                                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                                        .0,
                                    &mut holder_0,
                                )?,
                                &gil_refs_checker_0,
                            ),
                            py,
                        ),
                    )
                    .map_err(::core::convert::Into::<::pyo3::PyErr>::into),
            );
            gil_refs_checker_0.function_arg();
            result
        }
    }
}
mod attribute {
    use serde::{Deserialize, Serialize};
    use rand::Rng;
    use pyo3::prelude::*;
    use pyo3::types::{PyDict, PyString, PyFloat};
    use once_cell::sync::OnceCell;
    pub enum AttributeType {
        #[serde(rename = "socket.hostname")]
        Hostname,
        #[serde(rename = "random.session")]
        SessionRandom,
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AttributeType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    AttributeType::Hostname => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AttributeType",
                            0u32,
                            "socket.hostname",
                        )
                    }
                    AttributeType::SessionRandom => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AttributeType",
                            1u32,
                            "random.session",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AttributeType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "socket.hostname" => _serde::__private::Ok(__Field::__field0),
                            "random.session" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"socket.hostname" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"random.session" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AttributeType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AttributeType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum AttributeType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AttributeType::Hostname)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AttributeType::SessionRandom)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "socket.hostname",
                    "random.session",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "AttributeType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<AttributeType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for AttributeType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    AttributeType::Hostname => "Hostname",
                    AttributeType::SessionRandom => "SessionRandom",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AttributeType {
        #[inline]
        fn clone(&self) -> AttributeType {
            match self {
                AttributeType::Hostname => AttributeType::Hostname,
                AttributeType::SessionRandom => AttributeType::SessionRandom,
            }
        }
    }
    #[allow(deprecated)]
    unsafe impl ::pyo3::type_object::HasPyGilRef for AttributeType {
        type AsRefTarget = ::pyo3::PyCell<Self>;
    }
    unsafe impl ::pyo3::type_object::PyTypeInfo for AttributeType {
        const NAME: &'static str = "AttributeType";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <AttributeType as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    impl ::pyo3::PyClass for AttributeType {
        type Frozen = ::pyo3::pyclass::boolean_struct::False;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a AttributeType {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, AttributeType>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a mut AttributeType {
        type Holder = ::std::option::Option<::pyo3::PyRefMut<'py, AttributeType>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
        }
    }
    impl ::pyo3::IntoPy<::pyo3::PyObject> for AttributeType {
        fn into_py(self, py: ::pyo3::Python) -> ::pyo3::PyObject {
            ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for AttributeType {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = false;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = ::pyo3::PyAny;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<AttributeType>;
        type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = ::pyo3::PyAny;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[
                    ::pyo3::class::PyMethodDefType::ClassAttribute({
                        ::pyo3::class::PyClassAttributeDef::new(
                            { "Hostname\0" },
                            ::pyo3::impl_::pymethods::PyClassAttributeFactory(
                                AttributeType::__pymethod_Hostname__,
                            ),
                        )
                    }),
                    ::pyo3::class::PyMethodDefType::ClassAttribute({
                        ::pyo3::class::PyClassAttributeDef::new(
                            { "SessionRandom\0" },
                            ::pyo3::impl_::pymethods::PyClassAttributeFactory(
                                AttributeType::__pymethod_SessionRandom__,
                            ),
                        )
                    }),
                ],
                slots: &[
                    {
                        unsafe extern "C" fn trampoline(
                            _slf: *mut ::pyo3::ffi::PyObject,
                        ) -> *mut ::pyo3::ffi::PyObject {
                            ::pyo3::impl_::trampoline::reprfunc(
                                _slf,
                                AttributeType::__pymethod___default___pyo3__repr______,
                            )
                        }
                        ::pyo3::ffi::PyType_Slot {
                            slot: ::pyo3::ffi::Py_tp_repr,
                            pfunc: trampoline as ::pyo3::ffi::reprfunc as _,
                        }
                    },
                    {
                        unsafe extern "C" fn trampoline(
                            _slf: *mut ::pyo3::ffi::PyObject,
                        ) -> *mut ::pyo3::ffi::PyObject {
                            ::pyo3::impl_::trampoline::unaryfunc(
                                _slf,
                                AttributeType::__pymethod___default___pyo3__int______,
                            )
                        }
                        ::pyo3::ffi::PyType_Slot {
                            slot: ::pyo3::ffi::Py_nb_int,
                            pfunc: trampoline as ::pyo3::ffi::unaryfunc as _,
                        }
                    },
                    {
                        unsafe extern "C" fn trampoline(
                            _slf: *mut ::pyo3::ffi::PyObject,
                            arg0: *mut ::pyo3::ffi::PyObject,
                            arg1: ::std::os::raw::c_int,
                        ) -> *mut ::pyo3::ffi::PyObject {
                            ::pyo3::impl_::trampoline::richcmpfunc(
                                _slf,
                                arg0,
                                arg1,
                                AttributeType::__pymethod___default___pyo3__richcmp______,
                            )
                        }
                        ::pyo3::ffi::PyType_Slot {
                            slot: ::pyo3::ffi::Py_tp_richcompare,
                            pfunc: trampoline as ::pyo3::ffi::richcmpfunc as _,
                        }
                    },
                ],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <AttributeType as ::pyo3::PyTypeInfo>::NAME,
                            "\0",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<AttributeType> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl AttributeType {
        fn __pymethod_Hostname__(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                ::pyo3::IntoPy::into_py(AttributeType::Hostname, py),
            )
        }
        fn __pymethod_SessionRandom__(
            py: ::pyo3::Python<'_>,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            ::std::result::Result::Ok(
                ::pyo3::IntoPy::into_py(AttributeType::SessionRandom, py),
            )
        }
        unsafe fn __pymethod___default___pyo3__repr______(
            py: ::pyo3::Python<'_>,
            _raw_slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            let function = AttributeType::__pyo3__repr__;
            let _slf = _raw_slf;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let result = AttributeType::__pyo3__repr__(
                ::pyo3::impl_::extract_argument::extract_pyclass_ref::<
                    AttributeType,
                >(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                    &mut holder_0,
                )?,
            );
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod___default___pyo3__int______(
            py: ::pyo3::Python<'_>,
            _raw_slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            let function = AttributeType::__pyo3__int__;
            let _slf = _raw_slf;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let result = AttributeType::__pyo3__int__(
                ::pyo3::impl_::extract_argument::extract_pyclass_ref::<
                    AttributeType,
                >(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                    &mut holder_0,
                )?,
            );
            ::pyo3::callback::convert(py, result)
        }
        unsafe fn __pymethod___default___pyo3__richcmp______(
            py: ::pyo3::Python<'_>,
            _raw_slf: *mut ::pyo3::ffi::PyObject,
            arg0: *mut ::pyo3::ffi::PyObject,
            arg1: ::std::os::raw::c_int,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            let function = AttributeType::__pyo3__richcmp__;
            let _slf = _raw_slf;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = AttributeType::__pyo3__richcmp__(
                match ::pyo3::impl_::extract_argument::extract_pyclass_ref::<
                    AttributeType,
                >(
                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf).0,
                    &mut holder_0,
                ) {
                    ::std::result::Result::Ok(value) => value,
                    ::std::result::Result::Err(_) => {
                        return ::pyo3::callback::convert(py, py.NotImplemented());
                    }
                },
                py,
                ::pyo3::impl_::deprecations::inspect_type(
                    match ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &arg0).0,
                        &mut holder_1,
                        "other",
                    ) {
                        ::std::result::Result::Ok(value) => value,
                        ::std::result::Result::Err(_) => {
                            return ::pyo3::callback::convert(py, py.NotImplemented());
                        }
                    },
                    &gil_refs_checker_0,
                ),
                match ::pyo3::class::basic::CompareOp::from_raw(arg1)
                    .ok_or_else(|| ::pyo3::exceptions::PyValueError::new_err(
                        "invalid comparison operator",
                    ))
                {
                    ::std::result::Result::Ok(value) => value,
                    ::std::result::Result::Err(_) => {
                        return ::pyo3::callback::convert(py, py.NotImplemented());
                    }
                },
            );
            gil_refs_checker_0.function_arg();
            ::pyo3::callback::convert(py, result)
        }
    }
    impl AttributeType {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl AttributeType {
        fn __pyo3__repr__(&self) -> &'static str {
            match self {
                AttributeType::Hostname => "AttributeType.Hostname",
                AttributeType::SessionRandom => "AttributeType.SessionRandom",
            }
        }
        fn __pyo3__int__(&self) -> isize {
            match self {
                AttributeType::Hostname => AttributeType::Hostname as isize,
                AttributeType::SessionRandom => AttributeType::SessionRandom as isize,
            }
        }
        fn __pyo3__richcmp__(
            &self,
            py: ::pyo3::Python,
            other: &::pyo3::Bound<'_, ::pyo3::PyAny>,
            op: ::pyo3::basic::CompareOp,
        ) -> ::pyo3::PyResult<::pyo3::PyObject> {
            use ::pyo3::conversion::ToPyObject;
            use ::pyo3::types::PyAnyMethods;
            use ::core::result::Result::*;
            match op {
                ::pyo3::basic::CompareOp::Eq => {
                    let self_val = self.__pyo3__int__();
                    if let Ok(i) = other.extract::<isize>() {
                        return Ok((self_val == i).to_object(py));
                    }
                    if let Ok(other) = other.extract::<::pyo3::PyRef<Self>>() {
                        return Ok((self_val == other.__pyo3__int__()).to_object(py));
                    }
                    return Ok(py.NotImplemented());
                }
                ::pyo3::basic::CompareOp::Ne => {
                    let self_val = self.__pyo3__int__();
                    if let Ok(i) = other.extract::<isize>() {
                        return Ok((self_val != i).to_object(py));
                    }
                    if let Ok(other) = other.extract::<::pyo3::PyRef<Self>>() {
                        return Ok((self_val != other.__pyo3__int__()).to_object(py));
                    }
                    return Ok(py.NotImplemented());
                }
                _ => Ok(py.NotImplemented()),
            }
        }
    }
    impl AttributeType {
        fn members(py: Python) -> PyResult<Py<PyDict>> {
            let dict = PyDict::new(py);
            dict.set_item("socket.hostname", AttributeType::Hostname.into_py(py))?;
            dict.set_item("random.session", AttributeType::SessionRandom.into_py(py))?;
            Ok(dict.into())
        }
    }
    impl ::pyo3::impl_::pyclass::PyMethods<AttributeType>
    for ::pyo3::impl_::pyclass::PyClassImplCollector<AttributeType> {
        fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
            static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                methods: &[
                    ::pyo3::class::PyMethodDefType::Static(
                        ::pyo3::impl_::pymethods::PyMethodDef::noargs(
                                "members\0",
                                ::pyo3::impl_::pymethods::PyCFunction({
                                    unsafe extern "C" fn trampoline(
                                        _slf: *mut ::pyo3::ffi::PyObject,
                                        _args: *mut ::pyo3::ffi::PyObject,
                                    ) -> *mut ::pyo3::ffi::PyObject {
                                        ::pyo3::impl_::trampoline::noargs(
                                            _slf,
                                            _args,
                                            AttributeType::__pymethod_members__,
                                        )
                                    }
                                    trampoline
                                }),
                                "members()\n--\n\n\0",
                            )
                            .flags(::pyo3::ffi::METH_STATIC),
                    ),
                ],
                slots: &[],
            };
            &ITEMS
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl AttributeType {
        unsafe fn __pymethod_members__<'py>(
            py: ::pyo3::Python<'py>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            let _slf_ref = &_slf;
            let function = AttributeType::members;
            #[allow(clippy::let_unit_value)]
            let result = ::pyo3::impl_::wrap::map_result_into_ptr(
                py,
                ::pyo3::impl_::wrap::OkWrap::wrap(function(py))
                    .map_err(::core::convert::Into::<::pyo3::PyErr>::into),
            );
            result
        }
    }
    static SESSION_RANDOM_CACHE: OnceCell<PyObject> = OnceCell::new();
    pub struct Attribute {
        pub name: AttributeType,
        #[serde(rename = "type")]
        pub attribute_type: String,
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Attribute {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Attribute",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "type",
                    &self.attribute_type,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Attribute {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "type" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"type" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Attribute>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Attribute;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Attribute",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            AttributeType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Attribute with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Attribute with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Attribute {
                            name: __field0,
                            attribute_type: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<AttributeType> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            AttributeType,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("type"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("type")?
                            }
                        };
                        _serde::__private::Ok(Attribute {
                            name: __field0,
                            attribute_type: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["name", "type"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Attribute",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Attribute>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Attribute {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Attribute",
                "name",
                &self.name,
                "attribute_type",
                &&self.attribute_type,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Attribute {
        #[inline]
        fn clone(&self) -> Attribute {
            Attribute {
                name: ::core::clone::Clone::clone(&self.name),
                attribute_type: ::core::clone::Clone::clone(&self.attribute_type),
            }
        }
    }
    impl ::pyo3::types::DerefToPyAny for Attribute {}
    #[allow(deprecated)]
    unsafe impl ::pyo3::type_object::HasPyGilRef for Attribute {
        type AsRefTarget = ::pyo3::PyCell<Self>;
    }
    unsafe impl ::pyo3::type_object::PyTypeInfo for Attribute {
        const NAME: &'static str = "Attribute";
        const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
        #[inline]
        fn type_object_raw(py: ::pyo3::Python<'_>) -> *mut ::pyo3::ffi::PyTypeObject {
            use ::pyo3::prelude::PyTypeMethods;
            <Attribute as ::pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                .get_or_init(py)
                .as_type_ptr()
        }
    }
    impl ::pyo3::PyClass for Attribute {
        type Frozen = ::pyo3::pyclass::boolean_struct::False;
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a Attribute {
        type Holder = ::std::option::Option<::pyo3::PyRef<'py, Attribute>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
        }
    }
    impl<'a, 'py> ::pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
    for &'a mut Attribute {
        type Holder = ::std::option::Option<::pyo3::PyRefMut<'py, Attribute>>;
        #[inline]
        fn extract(
            obj: &'a ::pyo3::Bound<'py, ::pyo3::PyAny>,
            holder: &'a mut Self::Holder,
        ) -> ::pyo3::PyResult<Self> {
            ::pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
        }
    }
    impl ::pyo3::IntoPy<::pyo3::PyObject> for Attribute {
        fn into_py(self, py: ::pyo3::Python) -> ::pyo3::PyObject {
            ::pyo3::IntoPy::into_py(::pyo3::Py::new(py, self).unwrap(), py)
        }
    }
    impl ::pyo3::impl_::pyclass::PyClassImpl for Attribute {
        const IS_BASETYPE: bool = false;
        const IS_SUBCLASS: bool = false;
        const IS_MAPPING: bool = false;
        const IS_SEQUENCE: bool = false;
        type BaseType = ::pyo3::PyAny;
        type ThreadChecker = ::pyo3::impl_::pyclass::SendablePyClass<Attribute>;
        type PyClassMutability = <<::pyo3::PyAny as ::pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as ::pyo3::impl_::pycell::PyClassMutability>::MutableChild;
        type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
        type BaseNativeType = ::pyo3::PyAny;
        fn items_iter() -> ::pyo3::impl_::pyclass::PyClassItemsIter {
            use ::pyo3::impl_::pyclass::*;
            let collector = PyClassImplCollector::<Self>::new();
            static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                methods: &[],
                slots: &[],
            };
            PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
        }
        fn doc(py: ::pyo3::Python<'_>) -> ::pyo3::PyResult<&'static ::std::ffi::CStr> {
            use ::pyo3::impl_::pyclass::*;
            static DOC: ::pyo3::sync::GILOnceCell<
                ::std::borrow::Cow<'static, ::std::ffi::CStr>,
            > = ::pyo3::sync::GILOnceCell::new();
            DOC.get_or_try_init(
                    py,
                    || {
                        let collector = PyClassImplCollector::<Self>::new();
                        build_pyclass_doc(
                            <Attribute as ::pyo3::PyTypeInfo>::NAME,
                            "\0",
                            collector.new_text_signature(),
                        )
                    },
                )
                .map(::std::ops::Deref::deref)
        }
        fn lazy_type_object() -> &'static ::pyo3::impl_::pyclass::LazyTypeObject<Self> {
            use ::pyo3::impl_::pyclass::LazyTypeObject;
            static TYPE_OBJECT: LazyTypeObject<Attribute> = LazyTypeObject::new();
            &TYPE_OBJECT
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Attribute {}
    impl Attribute {
        #[doc(hidden)]
        pub const _PYO3_DEF: ::pyo3::impl_::pymodule::AddClassToModule<Self> = ::pyo3::impl_::pymodule::AddClassToModule::new();
    }
    impl Attribute {
        fn new(name: AttributeType, attribute_type: Option<String>) -> Self {
            Attribute {
                name,
                attribute_type: attribute_type
                    .unwrap_or_else(|| "callable-attribute".to_string()),
            }
        }
        pub fn eval(&self, py: Python) -> PyResult<PyObject> {
            match self.name {
                AttributeType::Hostname => {
                    Ok(
                        PyString::new(
                                py,
                                &gethostname::gethostname().into_string().unwrap(),
                            )
                            .into(),
                    )
                }
                AttributeType::SessionRandom => {
                    let random_value = SESSION_RANDOM_CACHE
                        .get_or_init(|| {
                            PyFloat::new(py, rand::thread_rng().gen_range(0.0..1.0))
                                .into_py(py)
                        });
                    Ok(random_value.clone_ref(py))
                }
            }
        }
    }
    impl ::pyo3::impl_::pyclass::PyMethods<Attribute>
    for ::pyo3::impl_::pyclass::PyClassImplCollector<Attribute> {
        fn py_methods(self) -> &'static ::pyo3::impl_::pyclass::PyClassItems {
            static ITEMS: ::pyo3::impl_::pyclass::PyClassItems = ::pyo3::impl_::pyclass::PyClassItems {
                methods: &[
                    ::pyo3::class::PyMethodDefType::Method(
                        ::pyo3::impl_::pymethods::PyMethodDef::noargs(
                            "eval\0",
                            ::pyo3::impl_::pymethods::PyCFunction({
                                unsafe extern "C" fn trampoline(
                                    _slf: *mut ::pyo3::ffi::PyObject,
                                    _args: *mut ::pyo3::ffi::PyObject,
                                ) -> *mut ::pyo3::ffi::PyObject {
                                    ::pyo3::impl_::trampoline::noargs(
                                        _slf,
                                        _args,
                                        Attribute::__pymethod_eval__,
                                    )
                                }
                                trampoline
                            }),
                            "eval($self)\n--\n\n\0",
                        ),
                    ),
                ],
                slots: &[
                    ::pyo3::ffi::PyType_Slot {
                        slot: ::pyo3::ffi::Py_tp_new,
                        pfunc: {
                            unsafe extern "C" fn trampoline(
                                subtype: *mut ::pyo3::ffi::PyTypeObject,
                                args: *mut ::pyo3::ffi::PyObject,
                                kwargs: *mut ::pyo3::ffi::PyObject,
                            ) -> *mut ::pyo3::ffi::PyObject {
                                use ::pyo3::impl_::pyclass::*;
                                #[allow(unknown_lints, non_local_definitions)]
                                impl PyClassNewTextSignature<Attribute>
                                for PyClassImplCollector<Attribute> {
                                    #[inline]
                                    fn new_text_signature(
                                        self,
                                    ) -> ::std::option::Option<&'static str> {
                                        ::std::option::Option::Some("(name, attribute_type=None)")
                                    }
                                }
                                ::pyo3::impl_::trampoline::newfunc(
                                    subtype,
                                    args,
                                    kwargs,
                                    Attribute::__pymethod___new____,
                                )
                            }
                            trampoline
                        } as ::pyo3::ffi::newfunc as _,
                    },
                ],
            };
            &ITEMS
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    impl Attribute {
        unsafe fn __pymethod___new____(
            py: ::pyo3::Python<'_>,
            _slf: *mut ::pyo3::ffi::PyTypeObject,
            _args: *mut ::pyo3::ffi::PyObject,
            _kwargs: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            use ::pyo3::callback::IntoPyCallbackOutput;
            let _slf_ref = &_slf;
            let function = Attribute::new;
            const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
                cls_name: ::std::option::Option::Some(
                    <Attribute as ::pyo3::type_object::PyTypeInfo>::NAME,
                ),
                func_name: "__new__",
                positional_parameter_names: &["name", "attribute_type"],
                positional_only_parameters: 0usize,
                required_positional_parameters: 1usize,
                keyword_only_parameters: &[],
            };
            let mut output = [::std::option::Option::None; 2usize];
            let (_args, _kwargs) = DESCRIPTION
                .extract_arguments_tuple_dict::<
                    ::pyo3::impl_::extract_argument::NoVarargs,
                    ::pyo3::impl_::extract_argument::NoVarkeywords,
                >(py, _args, _kwargs, &mut output)?;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let gil_refs_checker_1 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = Attribute::new(
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_argument(
                        ::pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[0usize].as_deref(),
                        ),
                        &mut holder_0,
                        "name",
                    )?,
                    &gil_refs_checker_0,
                ),
                ::pyo3::impl_::deprecations::inspect_type(
                    ::pyo3::impl_::extract_argument::extract_optional_argument(
                        output[1usize].as_deref(),
                        &mut holder_1,
                        "attribute_type",
                        #[allow(clippy::redundant_closure)]
                        { || ::std::option::Option::None },
                    )?,
                    &gil_refs_checker_1,
                ),
            );
            let initializer: ::pyo3::PyClassInitializer<Attribute> = result.convert(py)?;
            gil_refs_checker_0.function_arg();
            gil_refs_checker_1.function_arg();
            ::pyo3::impl_::pymethods::tp_new_impl(py, initializer, _slf)
        }
        unsafe fn __pymethod_eval__<'py>(
            py: ::pyo3::Python<'py>,
            _slf: *mut ::pyo3::ffi::PyObject,
        ) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
            let _slf_ref = &_slf;
            let function = Attribute::eval;
            #[allow(clippy::let_unit_value)]
            let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
            let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
            let result = ::pyo3::impl_::wrap::map_result_into_ptr(
                py,
                ::pyo3::impl_::wrap::OkWrap::wrap(
                        function(
                            ::pyo3::impl_::deprecations::inspect_type(
                                ::pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                    Attribute,
                                >(
                                    ::pyo3::impl_::pymethods::BoundRef::ref_from_ptr(py, &_slf)
                                        .0,
                                    &mut holder_0,
                                )?,
                                &gil_refs_checker_0,
                            ),
                            py,
                        ),
                    )
                    .map_err(::core::convert::Into::<::pyo3::PyErr>::into),
            );
            gil_refs_checker_0.function_arg();
            result
        }
    }
}
use classifier::{Classifier, Value};
use attribute::{Attribute, AttributeType};
struct Bucket {
    name: String,
    classifier: Classifier,
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for Bucket {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "Bucket",
                false as usize + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "name",
                &self.name,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "classifier",
                &self.classifier,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for Bucket {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "name" => _serde::__private::Ok(__Field::__field0),
                        "classifier" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"name" => _serde::__private::Ok(__Field::__field0),
                        b"classifier" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<Bucket>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = Bucket;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "struct Bucket")
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Bucket with 2 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        Classifier,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Bucket with 2 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(Bucket {
                        name: __field0,
                        classifier: __field1,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<Classifier> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "classifier",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<Classifier>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("name")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("classifier")?
                        }
                    };
                    _serde::__private::Ok(Bucket {
                        name: __field0,
                        classifier: __field1,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["name", "classifier"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "Bucket",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<Bucket>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
impl ::core::fmt::Debug for Bucket {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field2_finish(
            f,
            "Bucket",
            "name",
            &self.name,
            "classifier",
            &&self.classifier,
        )
    }
}
struct OfflineFeature {
    #[serde(rename = "type")]
    feature_type: String,
    python_versions: Vec<String>,
    buckets: Vec<Bucket>,
    values: HashMap<String, serde_json::Value>,
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for OfflineFeature {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "OfflineFeature",
                false as usize + 1 + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "type",
                &self.feature_type,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "python_versions",
                &self.python_versions,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "buckets",
                &self.buckets,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "values",
                &self.values,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for OfflineFeature {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "type" => _serde::__private::Ok(__Field::__field0),
                        "python_versions" => _serde::__private::Ok(__Field::__field1),
                        "buckets" => _serde::__private::Ok(__Field::__field2),
                        "values" => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"type" => _serde::__private::Ok(__Field::__field0),
                        b"python_versions" => _serde::__private::Ok(__Field::__field1),
                        b"buckets" => _serde::__private::Ok(__Field::__field2),
                        b"values" => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<OfflineFeature>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = OfflineFeature;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct OfflineFeature",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct OfflineFeature with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        Vec<String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct OfflineFeature with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        Vec<Bucket>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct OfflineFeature with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field3 = match _serde::de::SeqAccess::next_element::<
                        HashMap<String, serde_json::Value>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct OfflineFeature with 4 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(OfflineFeature {
                        feature_type: __field0,
                        python_versions: __field1,
                        buckets: __field2,
                        values: __field3,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<Vec<Bucket>> = _serde::__private::None;
                    let mut __field3: _serde::__private::Option<
                        HashMap<String, serde_json::Value>,
                    > = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("type"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "python_versions",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Vec<String>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "buckets",
                                        ),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Vec<Bucket>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("values"),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        HashMap<String, serde_json::Value>,
                                    >(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("type")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("python_versions")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("buckets")?
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("values")?
                        }
                    };
                    _serde::__private::Ok(OfflineFeature {
                        feature_type: __field0,
                        python_versions: __field1,
                        buckets: __field2,
                        values: __field3,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "type",
                "python_versions",
                "buckets",
                "values",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "OfflineFeature",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<OfflineFeature>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
impl ::core::fmt::Debug for OfflineFeature {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field4_finish(
            f,
            "OfflineFeature",
            "feature_type",
            &self.feature_type,
            "python_versions",
            &self.python_versions,
            "buckets",
            &self.buckets,
            "values",
            &&self.values,
        )
    }
}
fn get_bucket_name(py: Python, json_string: &str) -> PyResult<String> {
    let feature: OfflineFeature = serde_json::from_str(json_string)
        .map_err(|e| PyValueError::new_err(e.to_string()))?;
    for bucket in &feature.buckets {
        if bucket.classifier.eval(py) {
            return Ok(bucket.name.clone());
        }
    }
    Ok("default".to_string())
}
#[doc(hidden)]
mod get_bucket_name {
    pub(crate) struct MakeDef;
    pub const _PYO3_DEF: ::pyo3::impl_::pymethods::PyMethodDef = MakeDef::_PYO3_DEF;
}
#[allow(unknown_lints, non_local_definitions)]
impl get_bucket_name::MakeDef {
    const _PYO3_DEF: ::pyo3::impl_::pymethods::PyMethodDef = ::pyo3::impl_::pymethods::PyMethodDef::cfunction_with_keywords(
        "get_bucket_name\0",
        ::pyo3::impl_::pymethods::PyCFunctionWithKeywords({
            unsafe extern "C" fn trampoline(
                _slf: *mut ::pyo3::ffi::PyObject,
                _args: *mut ::pyo3::ffi::PyObject,
                _kwargs: *mut ::pyo3::ffi::PyObject,
            ) -> *mut ::pyo3::ffi::PyObject {
                ::pyo3::impl_::trampoline::cfunction_with_keywords(
                    _slf,
                    _args,
                    _kwargs,
                    __pyfunction_get_bucket_name,
                )
            }
            trampoline
        }),
        "get_bucket_name(json_string)\n--\n\n\0",
    );
}
#[allow(non_snake_case)]
unsafe fn __pyfunction_get_bucket_name<'py>(
    py: ::pyo3::Python<'py>,
    _slf: *mut ::pyo3::ffi::PyObject,
    _args: *mut ::pyo3::ffi::PyObject,
    _kwargs: *mut ::pyo3::ffi::PyObject,
) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
    let _slf_ref = &_slf;
    let function = get_bucket_name;
    const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
        cls_name: ::std::option::Option::None,
        func_name: "get_bucket_name",
        positional_parameter_names: &["json_string"],
        positional_only_parameters: 0usize,
        required_positional_parameters: 1usize,
        keyword_only_parameters: &[],
    };
    let mut output = [::std::option::Option::None; 1usize];
    let (_args, _kwargs) = DESCRIPTION
        .extract_arguments_tuple_dict::<
            ::pyo3::impl_::extract_argument::NoVarargs,
            ::pyo3::impl_::extract_argument::NoVarkeywords,
        >(py, _args, _kwargs, &mut output)?;
    #[allow(clippy::let_unit_value)]
    let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
    let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
    let gil_refs_checker_1 = ::pyo3::impl_::deprecations::GilRefs::new();
    let result = ::pyo3::impl_::wrap::map_result_into_ptr(
        py,
        ::pyo3::impl_::wrap::OkWrap::wrap(
                function(
                    ::pyo3::impl_::deprecations::inspect_type(py, &gil_refs_checker_0),
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_argument(
                            ::pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[0usize].as_deref(),
                            ),
                            &mut holder_0,
                            "json_string",
                        )?,
                        &gil_refs_checker_1,
                    ),
                ),
            )
            .map_err(::core::convert::Into::<::pyo3::PyErr>::into),
    );
    gil_refs_checker_0.function_arg();
    gil_refs_checker_1.function_arg();
    result
}
fn get_value_for_bucket(json_string: &str, bucket_name: &str) -> PyResult<String> {
    let feature: OfflineFeature = serde_json::from_str(json_string)
        .map_err(|e| PyValueError::new_err(e.to_string()))?;
    if let Some(value) = feature.values.get(bucket_name) {
        Ok(value.to_string())
    } else {
        Ok("".to_string())
    }
}
#[doc(hidden)]
mod get_value_for_bucket {
    pub(crate) struct MakeDef;
    pub const _PYO3_DEF: ::pyo3::impl_::pymethods::PyMethodDef = MakeDef::_PYO3_DEF;
}
#[allow(unknown_lints, non_local_definitions)]
impl get_value_for_bucket::MakeDef {
    const _PYO3_DEF: ::pyo3::impl_::pymethods::PyMethodDef = ::pyo3::impl_::pymethods::PyMethodDef::cfunction_with_keywords(
        "get_value_for_bucket\0",
        ::pyo3::impl_::pymethods::PyCFunctionWithKeywords({
            unsafe extern "C" fn trampoline(
                _slf: *mut ::pyo3::ffi::PyObject,
                _args: *mut ::pyo3::ffi::PyObject,
                _kwargs: *mut ::pyo3::ffi::PyObject,
            ) -> *mut ::pyo3::ffi::PyObject {
                ::pyo3::impl_::trampoline::cfunction_with_keywords(
                    _slf,
                    _args,
                    _kwargs,
                    __pyfunction_get_value_for_bucket,
                )
            }
            trampoline
        }),
        "get_value_for_bucket(json_string, bucket_name)\n--\n\n\0",
    );
}
#[allow(non_snake_case)]
unsafe fn __pyfunction_get_value_for_bucket<'py>(
    py: ::pyo3::Python<'py>,
    _slf: *mut ::pyo3::ffi::PyObject,
    _args: *mut ::pyo3::ffi::PyObject,
    _kwargs: *mut ::pyo3::ffi::PyObject,
) -> ::pyo3::PyResult<*mut ::pyo3::ffi::PyObject> {
    let _slf_ref = &_slf;
    let function = get_value_for_bucket;
    const DESCRIPTION: ::pyo3::impl_::extract_argument::FunctionDescription = ::pyo3::impl_::extract_argument::FunctionDescription {
        cls_name: ::std::option::Option::None,
        func_name: "get_value_for_bucket",
        positional_parameter_names: &["json_string", "bucket_name"],
        positional_only_parameters: 0usize,
        required_positional_parameters: 2usize,
        keyword_only_parameters: &[],
    };
    let mut output = [::std::option::Option::None; 2usize];
    let (_args, _kwargs) = DESCRIPTION
        .extract_arguments_tuple_dict::<
            ::pyo3::impl_::extract_argument::NoVarargs,
            ::pyo3::impl_::extract_argument::NoVarkeywords,
        >(py, _args, _kwargs, &mut output)?;
    #[allow(clippy::let_unit_value)]
    let mut holder_0 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
    let mut holder_1 = ::pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT;
    let gil_refs_checker_0 = ::pyo3::impl_::deprecations::GilRefs::new();
    let gil_refs_checker_1 = ::pyo3::impl_::deprecations::GilRefs::new();
    let result = ::pyo3::impl_::wrap::map_result_into_ptr(
        py,
        ::pyo3::impl_::wrap::OkWrap::wrap(
                function(
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_argument(
                            ::pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[0usize].as_deref(),
                            ),
                            &mut holder_0,
                            "json_string",
                        )?,
                        &gil_refs_checker_0,
                    ),
                    ::pyo3::impl_::deprecations::inspect_type(
                        ::pyo3::impl_::extract_argument::extract_argument(
                            ::pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[1usize].as_deref(),
                            ),
                            &mut holder_1,
                            "bucket_name",
                        )?,
                        &gil_refs_checker_1,
                    ),
                ),
            )
            .map_err(::core::convert::Into::<::pyo3::PyErr>::into),
    );
    gil_refs_checker_0.function_arg();
    gil_refs_checker_1.function_arg();
    result
}
#[allow(clippy::used_underscore_binding)]
fn rust_of(_py: Python, m: &PyModule) -> PyResult<()> {
    let check_gil_refs = ::pyo3::impl_::deprecations::GilRefs::new();
    let _py = ::pyo3::impl_::deprecations::inspect_type(_py, &check_gil_refs);
    check_gil_refs.function_arg();
    let check_gil_refs = ::pyo3::impl_::deprecations::GilRefs::new();
    let m = ::pyo3::impl_::deprecations::inspect_type(m, &check_gil_refs);
    check_gil_refs.function_arg();
    #[allow(unknown_lints, unused_imports, redundant_imports)]
    use ::pyo3::{PyNativeType, types::PyModuleMethods};
    m.add_function(
        {
            use get_bucket_name as wrapped_pyfunction;
            let check_gil_refs = ::pyo3::impl_::deprecations::GilRefs::new();
            let py_or_module = ::pyo3::impl_::deprecations::inspect_type(
                m,
                &check_gil_refs,
            );
            check_gil_refs.is_python();
            ::pyo3::impl_::pyfunction::WrapPyFunctionArg::wrap_pyfunction(
                py_or_module,
                &wrapped_pyfunction::_PYO3_DEF,
            )
        }?,
    )?;
    m.add_function(
        {
            use get_value_for_bucket as wrapped_pyfunction;
            let check_gil_refs = ::pyo3::impl_::deprecations::GilRefs::new();
            let py_or_module = ::pyo3::impl_::deprecations::inspect_type(
                m,
                &check_gil_refs,
            );
            check_gil_refs.is_python();
            ::pyo3::impl_::pyfunction::WrapPyFunctionArg::wrap_pyfunction(
                py_or_module,
                &wrapped_pyfunction::_PYO3_DEF,
            )
        }?,
    )?;
    m.add_class::<Attribute>()?;
    m.add_class::<AttributeType>()?;
    m.add_class::<Classifier>()?;
    Ok(())
}
#[doc(hidden)]
mod rust_of {
    #[doc(hidden)]
    pub const __PYO3_NAME: &'static str = "rust_of\u{0}";
    pub(super) struct MakeDef;
    #[doc(hidden)]
    pub static _PYO3_DEF: ::pyo3::impl_::pymodule::ModuleDef = MakeDef::make_def();
    /// This autogenerated function is called by the python interpreter when importing
    /// the module.
    #[doc(hidden)]
    #[export_name = "PyInit_rust_of"]
    pub unsafe extern "C" fn __pyo3_init() -> *mut ::pyo3::ffi::PyObject {
        ::pyo3::impl_::trampoline::module_init(|py| _PYO3_DEF.make_module(py))
    }
}
#[allow(unknown_lints, non_local_definitions)]
impl rust_of::MakeDef {
    const fn make_def() -> ::pyo3::impl_::pymodule::ModuleDef {
        fn __pyo3_pymodule(
            module: &::pyo3::Bound<'_, ::pyo3::types::PyModule>,
        ) -> ::pyo3::PyResult<()> {
            rust_of(
                module.py(),
                ::std::convert::Into::into(::pyo3::impl_::pymethods::BoundRef(module)),
            )
        }
        const INITIALIZER: ::pyo3::impl_::pymodule::ModuleInitializer = ::pyo3::impl_::pymodule::ModuleInitializer(
            __pyo3_pymodule,
        );
        unsafe {
            ::pyo3::impl_::pymodule::ModuleDef::new(
                rust_of::__PYO3_NAME,
                "\0",
                INITIALIZER,
            )
        }
    }
}
